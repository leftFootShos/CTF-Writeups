## Description

[Problem source](https://exploit-exercises.com/protostar/stack4/)


### Solution

In order to solve this problem we need an understanding of cdecl calling
convention used by the c programs on linux.

Everytime the function is called return address is pushed on the stack before
the thread of execution jumps to the function. First thing the function does is
to push `$ebp` onto stack, and move `$esp` to `$ebp`. Then the stack is aligned
 and place is alocated for local variables. Since return address resides on the
 higher address we can overflow the local variable and overwrite it. When the
 function returns it will read the returning address from the changed address.

[ Return Address ]
[ EBP ]
[ Some Aligment ]
[ Local Variables ] <-- Stack pointer


In our case `buffer` variable resides at 0x10 offset from `$esp`

Beginning of the stack frame is at the offset 0x50 (local variables) + 0x08
(offset) +  0x04 (ebp) = 0x5c We need to write 0x5c - 0x10 = 0x4c (76) bytes to
the buffer + desired value to overwrite the return address.

	python -c "print('a'* 76 + '\xf4\x83\x04\x08')" | ./stack4
