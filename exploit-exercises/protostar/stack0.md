### Description

[Problem source](https://exploit-exercises.com/protostar/stack0/)


## Solution


The first five problems in this problem set are about stack buffer overflow. All
the programs are 32 bit ELF executables, without any stack protection, so
overflowing a stack variable is pretty easy in all cases.

To solve this level we have to change `modified` variable. Since it's the 32 bit
executable on linux, it uses `cdecl` calling convention. Let's fire up gdb and
see what happens under the hood. (Note: Running gdb will invalidate the
`SETUID` bit, but we don't care about privilages in this example, we just want
to modify local variable).


	<main>:       push   %ebp
	<main+1>:     mov    %esp,%ebp
	<main+3>:     and    $0xfffffff0,%esp
	<main+6>:     sub    $0x60,%esp
	<main+9>:     movl   $0x0,0x5c(%esp)
	<main+17>:    lea 0x1c(%esp),%eax
	<main+17>:    lea    0x1c(%esp),%eax
	<main+21>:    mov    %eax,(%esp)

Program allocates 0x60 bytes of memory for local variables, `buffer` variable
starts at 0x1c offset from $esp and `modified` at 0x5c. 0x5c - 0x1c = 0x40 = 64
bytes. So buffer and modified are located next to each other in the memory. If
we write anything past 64 bytes in buffer, it will be written in modified. Since
`gets()` doesn't check for the input size, we can simply produce 64 + 1
characters to the stdin and variable `modified` will be modified.

	python -c "print('a' * 65)" | ./stack01


## Lessions learned

SETUID programs can be ptraced, but they drop the SETUID bit.


## Problems

Why does the compiler subtract 0x60 from the $esp when all it needs is 0x44 for
local variables and additional 0x04 for parameter passing.
